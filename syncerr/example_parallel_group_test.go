package syncerr_test

import (
	"fmt"

	"github.com/secureworks/errors"
	"github.com/secureworks/errors/syncerr"
)

// ParallelGroups are a version of CoordinatedGroups optimized for
// running a set of tasks that must be completed before moving on in a
// routine, while retaining access to all errors generated by any task.
//
// We can use a zero value version of the group to synchronize on all
// tasks completing (like in CoordinatedGroups) and wait on the result.
// To make it easier to range over the outcome we can return an
// errors.MultiError directly too.
func Example_parallelGroup() {
	printTask := func(workload string, i int) error {
		if 0 == i%2 {
			return errors.New("error with task: " + workload)
		}
		fmt.Print("\ntask: ", workload)
		return nil
	}

	group := new(syncerr.ParallelGroup)
	for i, name := range []string{"wk", "wk", "wk", "wk"} {
		i, name := i, name // https://golang.org/doc/faq#closures_and_goroutines
		group.Go(func() error { return printTask(name, i) })
	}
	merr := group.WaitForMultiError()

	fmt.Println()
	fmt.Println()

	for _, err := range merr.Unwrap() {
		fmt.Println(err)
	}

	// Output:
	// task: wk
	// task: wk
	//
	// error with task: wk
	// error with task: wk
}
